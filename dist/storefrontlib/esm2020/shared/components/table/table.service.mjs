/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
import { Injectable, inject, isDevMode } from '@angular/core';
import { LoggerService } from '@spartacus/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../../layout/breakpoint/breakpoint.service";
import * as i2 from "./config/table.config";
/**
 * Responsive table service.
 *
 * The `TableService` is used to build a `TableStructure` by configuration. The configuration
 * allows for breakpoint specific configuration, so that the table can differentiate for
 * various screen sizes.
 *
 * While there are some global options, the configuration is mainly driven by the table _type_.
 *
 * If there is no table configuration for the given type found, a table header structure
 * is generated based on the actual data (if available) or randomly by generating 5 random headers.
 */
export class TableService {
    constructor(breakpointService, config) {
        this.breakpointService = breakpointService;
        this.config = config;
        this.logger = inject(LoggerService);
    }
    /**
     * Builds the table structure.
     *
     * @param tableType The table type is used  to find the specific table configuration.
     * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
     * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
     */
    buildStructure(tableType, defaultStructure) {
        if (this.hasTableConfig(tableType)) {
            return this.buildStructureFromConfig(tableType, defaultStructure);
        }
        else {
            return this.buildRandomStructure(tableType);
        }
    }
    /**
     * Returns the table structure by configuration. The configuration can be
     * breakpoint-driven, which means that an alternative header structure can
     * be created per screen size.
     *
     * The breakpoint is resolved by teh `BreakpointService`.
     */
    buildStructureFromConfig(type, defaultStructure) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => ({
            ...this.getTableConfig(type, breakpoint, defaultStructure),
            type,
        })));
    }
    /**
     * Finds all applicable table configuration for the given type and breakpoint.
     * The default table configuration is merged with all relevant breakpoint
     * configurations.
     *
     * This allows to have some default configurations that apply to all screens, and
     * add configuration options for some screens.
     */
    getTableConfig(type, breakpoint, defaultStructure) {
        if (!this.config.table?.[type]) {
            return null;
        }
        const relevant = this.findRelevantBreakpoints(breakpoint);
        const closestBreakpoint = [...relevant]
            .reverse()
            .find((br) => !!this.config.table?.[type][br]?.cells);
        const cells = (closestBreakpoint &&
            this.config.table[type][closestBreakpoint]?.cells) ||
            this.config.table[type].cells ||
            defaultStructure?.cells;
        // add all default table configurations
        let options = {
            ...defaultStructure?.options,
            ...this.config.table[type].options,
        };
        // We merge all table options for smaller breakpoints into the global
        // options, so we inherit options.
        relevant.forEach((br) => {
            options = {
                ...options,
                ...defaultStructure?.[br]?.options,
                ...this.config.table?.[type]?.[br]?.options,
            };
        });
        return { cells, options };
    }
    /**
     * Generates the table structure by the help of the first data row.
     */
    buildStructureFromData(type, data$) {
        this.logWarning(`No table configuration found to render table with type "${type}". The table header for "${type}" is generated by the help of the first data item`);
        return data$.pipe(map((data) => {
            const cells = Object.keys(data?.[0]).map((key) => key);
            return { type, cells };
        }));
    }
    /**
     * As a last resort, the table structure is randomly created. The random structure
     * contains 5 headers, so that some of the unknown data is visualized.
     */
    buildRandomStructure(type) {
        this.logWarning(`No data available for "${type}", a random structure is generated (with hidden table headers).`);
        return of({
            type,
            cells: ['unknown', 'unknown', 'unknown', 'unknown', 'unknown'],
        });
    }
    /**
     * Finds all the breakpoints can contribute to the table configuration, from small
     * to current.
     *
     * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
     */
    findRelevantBreakpoints(breakpoint) {
        const current = this.breakpointService.breakpoints.indexOf(breakpoint);
        return this.breakpointService.breakpoints.slice(0, current + 1);
    }
    /**
     * Indicates if the there is a configuration for the table available.
     */
    hasTableConfig(tableType) {
        return !!this.config.table?.[tableType];
    }
    /**
     * Logs a message in the console to increase developer experience.
     *
     * The message is only logged in dev mode.
     */
    logWarning(message) {
        if (isDevMode()) {
            this.logger.warn(message);
        }
    }
}
TableService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.9", ngImport: i0, type: TableService, deps: [{ token: i1.BreakpointService }, { token: i2.TableConfig }], target: i0.ɵɵFactoryTarget.Injectable });
TableService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.9", ngImport: i0, type: TableService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.9", ngImport: i0, type: TableService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.BreakpointService }, { type: i2.TableConfig }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc2hhcmVkL2NvbXBvbmVudHMvdGFibGUvdGFibGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzlELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQVNyQzs7Ozs7Ozs7Ozs7R0FXRztBQUlILE1BQU0sT0FBTyxZQUFZO0lBR3ZCLFlBQ1ksaUJBQW9DLEVBQ3BDLE1BQW1CO1FBRG5CLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDcEMsV0FBTSxHQUFOLE1BQU0sQ0FBYTtRQUpyQixXQUFNLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBS3RDLENBQUM7SUFFSjs7Ozs7O09BTUc7SUFDSCxjQUFjLENBQ1osU0FBaUIsRUFDakIsZ0JBQStDO1FBRS9DLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNsQyxPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztTQUNuRTthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDN0M7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ08sd0JBQXdCLENBQ2hDLElBQVksRUFDWixnQkFBK0M7UUFFL0MsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLElBQUksQ0FDNUMsR0FBRyxDQUFD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QkFBdUIsQ0FBQyxVQUFzQjtRQUN0RCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN2RSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVEOztPQUVHO0lBQ08sY0FBYyxDQUFDLFNBQWlCO1FBQ3hDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxVQUFVLENBQUMsT0FBZTtRQUNoQyxJQUFJLFNBQVMsRUFBRSxFQUFFO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDM0I7SUFDSCxDQUFDOzt5R0F2SlUsWUFBWTs2R0FBWixZQUFZLGNBRlgsTUFBTTsyRkFFUCxZQUFZO2tCQUh4QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiAyMDIzIFNBUCBTcGFydGFjdXMgdGVhbSA8c3BhcnRhY3VzLXRlYW1Ac2FwLmNvbT5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIGluamVjdCwgaXNEZXZNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMb2dnZXJTZXJ2aWNlIH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBCcmVha3BvaW50U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2xheW91dC9icmVha3BvaW50L2JyZWFrcG9pbnQuc2VydmljZSc7XG5pbXBvcnQgeyBCUkVBS1BPSU5UIH0gZnJvbSAnLi4vLi4vLi4vbGF5b3V0L2NvbmZpZy9sYXlvdXQtY29uZmlnJztcbmltcG9ydCB7XG4gIFJlc3BvbnNpdmVUYWJsZUNvbmZpZ3VyYXRpb24sXG4gIFRhYmxlQ29uZmlnLFxufSBmcm9tICcuL2NvbmZpZy90YWJsZS5jb25maWcnO1xuaW1wb3J0IHsgVGFibGVTdHJ1Y3R1cmUsIFRhYmxlU3RydWN0dXJlQ29uZmlndXJhdGlvbiB9IGZyb20gJy4vdGFibGUubW9kZWwnO1xuXG4vKipcbiAqIFJlc3BvbnNpdmUgdGFibGUgc2VydmljZS5cbiAqXG4gKiBUaGUgYFRhYmxlU2VydmljZWAgaXMgdXNlZCB0byBidWlsZCBhIGBUYWJsZVN0cnVjdHVyZWAgYnkgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb25cbiAqIGFsbG93cyBmb3IgYnJlYWtwb2ludCBzcGVjaWZpYyBjb25maWd1cmF0aW9uLCBzbyB0aGF0IHRoZSB0YWJsZSBjYW4gZGlmZmVyZW50aWF0ZSBmb3JcbiAqIHZhcmlvdXMgc2NyZWVuIHNpemVzLlxuICpcbiAqIFdoaWxlIHRoZXJlIGFyZSBzb21lIGdsb2JhbCBvcHRpb25zLCB0aGUgY29uZmlndXJhdGlvbiBpcyBtYWlubHkgZHJpdmVuIGJ5IHRoZSB0YWJsZSBfdHlwZV8uXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gdGFibGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGdpdmVuIHR5cGUgZm91bmQsIGEgdGFibGUgaGVhZGVyIHN0cnVjdHVyZVxuICogaXMgZ2VuZXJhdGVkIGJhc2VkIG9uIHRoZSBhY3R1YWwgZGF0YSAoaWYgYXZhaWxhYmxlKSBvciByYW5kb21seSBieSBnZW5lcmF0aW5nIDUgcmFuZG9tIGhlYWRlcnMuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZVNlcnZpY2Uge1xuICBwcm90ZWN0ZWQgbG9nZ2VyID0gaW5qZWN0KExvZ2dlclNlcnZpY2UpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBicmVha3BvaW50U2VydmljZTogQnJlYWtwb2ludFNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogVGFibGVDb25maWdcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIHRhYmxlIHN0cnVjdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHRhYmxlVHlwZSBUaGUgdGFibGUgdHlwZSBpcyB1c2VkICB0byBmaW5kIHRoZSBzcGVjaWZpYyB0YWJsZSBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0gZGVmYXVsdFN0cnVjdHVyZSAob3B0aW9uYWwpIERlZmF1bHQgdGFibGUgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgZmFsbGJhY2sgb3B0aW9ucy4gTW9yZSBzcGVjaWZpYyBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdCBzdHJ1Y3R1cmUuXG4gICAqIEBwYXJhbSBkYXRhJCAob3B0aW9uYWwpIFRoZSBhY3R1YWwgZGF0YSBjYW4gYmUgcGFzc2VkIGluIHRvIGdlbmVyYXRlIHRoZSB0YWJsZSBzdHJ1Y3R1cmUgYmFzZWQgb24gYWN0dWFsIGRhdGEuXG4gICAqL1xuICBidWlsZFN0cnVjdHVyZShcbiAgICB0YWJsZVR5cGU6IHN0cmluZyxcbiAgICBkZWZhdWx0U3RydWN0dXJlPzogUmVzcG9uc2l2ZVRhYmxlQ29uZmlndXJhdGlvblxuICApOiBPYnNlcnZhYmxlPFRhYmxlU3RydWN0dXJlPiB7XG4gICAgaWYgKHRoaXMuaGFzVGFibGVDb25maWcodGFibGVUeXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTdHJ1Y3R1cmVGcm9tQ29uZmlnKHRhYmxlVHlwZSwgZGVmYXVsdFN0cnVjdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkUmFuZG9tU3RydWN0dXJlKHRhYmxlVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhYmxlIHN0cnVjdHVyZSBieSBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBjYW4gYmVcbiAgICogYnJlYWtwb2ludC1kcml2ZW4sIHdoaWNoIG1lYW5zIHRoYXQgYW4gYWx0ZXJuYXRpdmUgaGVhZGVyIHN0cnVjdHVyZSBjYW5cbiAgICogYmUgY3JlYXRlZCBwZXIgc2NyZWVuIHNpemUuXG4gICAqXG4gICAqIFRoZSBicmVha3BvaW50IGlzIHJlc29sdmVkIGJ5IHRlaCBgQnJlYWtwb2ludFNlcnZpY2VgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkU3RydWN0dXJlRnJvbUNvbmZpZyhcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgZGVmYXVsdFN0cnVjdHVyZT86IFJlc3BvbnNpdmVUYWJsZUNvbmZpZ3VyYXRpb25cbiAgKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRTZXJ2aWNlLmJyZWFrcG9pbnQkLnBpcGUoXG4gICAgICBtYXAoKGJyZWFrcG9pbnQpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuZ2V0VGFibGVDb25maWcodHlwZSwgYnJlYWtwb2ludCwgZGVmYXVsdFN0cnVjdHVyZSksXG4gICAgICAgIHR5cGUsXG4gICAgICB9KSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBhcHBsaWNhYmxlIHRhYmxlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBicmVha3BvaW50LlxuICAgKiBUaGUgZGVmYXVsdCB0YWJsZSBjb25maWd1cmF0aW9uIGlzIG1lcmdlZCB3aXRoIGFsbCByZWxldmFudCBicmVha3BvaW50XG4gICAqIGNvbmZpZ3VyYXRpb25zLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyB0byBoYXZlIHNvbWUgZGVmYXVsdCBjb25maWd1cmF0aW9ucyB0aGF0IGFwcGx5IHRvIGFsbCBzY3JlZW5zLCBhbmRcbiAgICogYWRkIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Igc29tZSBzY3JlZW5zLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFRhYmxlQ29uZmlnKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBicmVha3BvaW50OiBCUkVBS1BPSU5ULFxuICAgIGRlZmF1bHRTdHJ1Y3R1cmU/OiBSZXNwb25zaXZlVGFibGVDb25maWd1cmF0aW9uXG4gICk6IFRhYmxlU3RydWN0dXJlQ29uZmlndXJhdGlvbiB8IG51bGwge1xuICAgIGlmICghdGhpcy5jb25maWcudGFibGU/Llt0eXBlXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVsZXZhbnQgPSB0aGlzLmZpbmRSZWxldmFudEJyZWFrcG9pbnRzKGJyZWFrcG9pbnQpO1xuXG4gICAgY29uc3QgY2xvc2VzdEJyZWFrcG9pbnQgPSBbLi4ucmVsZXZhbnRdXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZCgoYnIpID0+ICEhdGhpcy5jb25maWcudGFibGU/Llt0eXBlXVticl0/LmNlbGxzKTtcbiAgICBjb25zdCBjZWxscyA9XG4gICAgICAoY2xvc2VzdEJyZWFrcG9pbnQgJiZcbiAgICAgICAgdGhpcy5jb25maWcudGFibGVbdHlwZV1bY2xvc2VzdEJyZWFrcG9pbnRdPy5jZWxscykgfHxcbiAgICAgIHRoaXMuY29uZmlnLnRhYmxlW3R5cGVdLmNlbGxzIHx8XG4gICAgICBkZWZhdWx0U3RydWN0dXJlPy5jZWxscztcblxuICAgIC8vIGFkZCBhbGwgZGVmYXVsdCB0YWJsZSBjb25maWd1cmF0aW9uc1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgLi4uZGVmYXVsdFN0cnVjdHVyZT8ub3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuY29uZmlnLnRhYmxlW3R5cGVdLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIC8vIFdlIG1lcmdlIGFsbCB0YWJsZSBvcHRpb25zIGZvciBzbWFsbGVyIGJyZWFrcG9pbnRzIGludG8gdGhlIGdsb2JhbFxuICAgIC8vIG9wdGlvbnMsIHNvIHdlIGluaGVyaXQgb3B0aW9ucy5cbiAgICByZWxldmFudC5mb3JFYWNoKChicikgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4uZGVmYXVsdFN0cnVjdHVyZT8uW2JyXT8ub3B0aW9ucyxcbiAgICAgICAgLi4udGhpcy5jb25maWcudGFibGU/Llt0eXBlXT8uW2JyXT8ub3B0aW9ucyxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBjZWxscywgb3B0aW9ucyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgdGFibGUgc3RydWN0dXJlIGJ5IHRoZSBoZWxwIG9mIHRoZSBmaXJzdCBkYXRhIHJvdy5cbiAgICovXG4gIHByb3RlY3RlZCBidWlsZFN0cnVjdHVyZUZyb21EYXRhKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBkYXRhJDogT2JzZXJ2YWJsZTxhbnk+XG4gICk6IE9ic2VydmFibGU8VGFibGVTdHJ1Y3R1cmU+IHtcbiAgICB0aGlzLmxvZ1dhcm5pbmcoXG4gICAgICBgTm8gdGFibGUgY29uZmlndXJhdGlvbiBmb3VuZCB0byByZW5kZXIgdGFibGUgd2l0aCB0eXBlIFwiJHt0eXBlfVwiLiBUaGUgdGFibGUgaGVhZGVyIGZvciBcIiR7dHlwZX1cIiBpcyBnZW5lcmF0ZWQgYnkgdGhlIGhlbHAgb2YgdGhlIGZpcnN0IGRhdGEgaXRlbWBcbiAgICApO1xuICAgIHJldHVybiBkYXRhJC5waXBlKFxuICAgICAgbWFwKChkYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgICBjb25zdCBjZWxscyA9IE9iamVjdC5rZXlzKGRhdGE/LlswXSkubWFwKChrZXkpID0+IGtleSk7XG4gICAgICAgIHJldHVybiB7IHR5cGUsIGNlbGxzIH0gYXMgVGFibGVTdHJ1Y3R1cmU7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQXMgYSBsYXN0IHJlc29ydCwgdGhlIHRhYmxlIHN0cnVjdHVyZSBpcyByYW5kb21seSBjcmVhdGVkLiBUaGUgcmFuZG9tIHN0cnVjdHVyZVxuICAgKiBjb250YWlucyA1IGhlYWRlcnMsIHNvIHRoYXQgc29tZSBvZiB0aGUgdW5rbm93biBkYXRhIGlzIHZpc3VhbGl6ZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRSYW5kb21TdHJ1Y3R1cmUodHlwZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIHRoaXMubG9nV2FybmluZyhcbiAgICAgIGBObyBkYXRhIGF2YWlsYWJsZSBmb3IgXCIke3R5cGV9XCIsIGEgcmFuZG9tIHN0cnVjdHVyZSBpcyBnZW5lcmF0ZWQgKHdpdGggaGlkZGVuIHRhYmxlIGhlYWRlcnMpLmBcbiAgICApO1xuICAgIHJldHVybiBvZih7XG4gICAgICB0eXBlLFxuICAgICAgY2VsbHM6IFsndW5rbm93bicsICd1bmtub3duJywgJ3Vua25vd24nLCAndW5rbm93bicsICd1bmtub3duJ10sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYWxsIHRoZSBicmVha3BvaW50cyBjYW4gY29udHJpYnV0ZSB0byB0aGUgdGFibGUgY29uZmlndXJhdGlvbiwgZnJvbSBzbWFsbFxuICAgKiB0byBjdXJyZW50LlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBpcyBgTURgLCB0aGlzIHJldHVybnMgYFtYUywgU00sIE1EXWAuXG4gICAqL1xuICBwcm90ZWN0ZWQgZmluZFJlbGV2YW50QnJlYWtwb2ludHMoYnJlYWtwb2ludDogQlJFQUtQT0lOVCk6IEJSRUFLUE9JTlRbXSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuYnJlYWtwb2ludFNlcnZpY2UuYnJlYWtwb2ludHMuaW5kZXhPZihicmVha3BvaW50KTtcbiAgICByZXR1cm4gdGhpcy5icmVha3BvaW50U2VydmljZS5icmVha3BvaW50cy5zbGljZSgwLCBjdXJyZW50ICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSB0aGVyZSBpcyBhIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSB0YWJsZSBhdmFpbGFibGUuXG4gICAqL1xuICBwcm90ZWN0ZWQgaGFzVGFibGVDb25maWcodGFibGVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmNvbmZpZy50YWJsZT8uW3RhYmxlVHlwZV07XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgdG8gaW5jcmVhc2UgZGV2ZWxvcGVyIGV4cGVyaWVuY2UuXG4gICAqXG4gICAqIFRoZSBtZXNzYWdlIGlzIG9ubHkgbG9nZ2VkIGluIGRldiBtb2RlLlxuICAgKi9cbiAgcHJpdmF0ZSBsb2dXYXJuaW5nKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==