/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
import { isPlatformBrowser } from '@angular/common';
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { createEffect, ofType } from '@ngrx/effects';
import { select } from '@ngrx/store';
import { EMPTY, of } from 'rxjs';
import { concatMap, delay, filter, map, switchMap, take, withLatestFrom, } from 'rxjs/operators';
import { ObjectComparisonUtils } from '../../../util/object-comparison-utils';
import { isNotUndefined } from '../../../util/type-guards';
import { GlobalMessageActions } from '../actions/index';
import { GlobalMessageSelectors } from '../selectors/index';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/effects";
import * as i2 from "@ngrx/store";
import * as i3 from "../../config/global-message-config";
export class GlobalMessageEffect {
    constructor(actions$, store, config, platformId) {
        this.actions$ = actions$;
        this.store = store;
        this.config = config;
        this.platformId = platformId;
        this.removeDuplicated$ = createEffect(() => this.actions$.pipe(ofType(GlobalMessageActions.ADD_MESSAGE), map((action) => action.payload), switchMap((message) => of(message.text).pipe(withLatestFrom(this.store.pipe(select(GlobalMessageSelectors.getGlobalMessageEntitiesByType(message.type)))), filter(([text, messages]) => ObjectComparisonUtils.countOfDeepEqualObjects(text, messages) >
            1), map(([text, messages]) => {
            const index = ObjectComparisonUtils.indexOfFirstOccurrence(text, messages);
            if (index !== undefined) {
                return new GlobalMessageActions.RemoveMessage({
                    type: message.type,
                    index,
                });
            }
        }), filter(isNotUndefined)))));
        this.hideAfterDelay$ = createEffect(() => isPlatformBrowser(this.platformId) // we don't want to run this logic when doing SSR
            ? this.actions$.pipe(ofType(GlobalMessageActions.ADD_MESSAGE), map((action) => action.payload), concatMap((message) => {
                const config = this.config.globalMessages?.[message.type];
                return this.store.pipe(select(GlobalMessageSelectors.getGlobalMessageCountByType(message.type)), take(1), filter((count) => ((config && config.timeout !== undefined) ||
                    message.timeout !== undefined) &&
                    count > 0), delay(message.timeout || config?.timeout), switchMap(() => of(new GlobalMessageActions.RemoveMessage({
                    type: message.type,
                    index: 0,
                }))));
            }))
            : // workaround is required due to NGRX mutating a global static
                // observable EMPTY, causing to throw an error if we have
                // effect registered on the same observable twice
                () => EMPTY);
    }
}
GlobalMessageEffect.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.9", ngImport: i0, type: GlobalMessageEffect, deps: [{ token: i1.Actions }, { token: i2.Store }, { token: i3.GlobalMessageConfig }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
GlobalMessageEffect.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.9", ngImport: i0, type: GlobalMessageEffect });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.9", ngImport: i0, type: GlobalMessageEffect, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Actions }, { type: i2.Store }, { type: i3.GlobalMessageConfig }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xvYmFsLW1lc3NhZ2UuZWZmZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zcmMvZ2xvYmFsLW1lc3NhZ2Uvc3RvcmUvZWZmZWN0cy9nbG9iYWwtbWVzc2FnZS5lZmZlY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQVcsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RCxPQUFPLEVBQVMsTUFBTSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxLQUFLLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixHQUFHLEVBQ0gsU0FBUyxFQUNULElBQUksRUFDSixjQUFjLEdBQ2YsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUM5RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFM0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFeEQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7Ozs7O0FBRzVELE1BQU0sT0FBTyxtQkFBbUI7SUE4RTlCLFlBQ1UsUUFBaUIsRUFDakIsS0FBb0MsRUFDcEMsTUFBMkIsRUFDTixVQUFlO1FBSHBDLGFBQVEsR0FBUixRQUFRLENBQVM7UUFDakIsVUFBSyxHQUFMLEtBQUssQ0FBK0I7UUFDcEMsV0FBTSxHQUFOLE1BQU0sQ0FBcUI7UUFDTixl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LG1CQUFtQixpR0FrRnBCLFdBQVc7b0hBbEZWLG1CQUFtQjsyRkFBbkIsbUJBQW1CO2tCQUQvQixVQUFVOzswQkFtRk4sTUFBTTsyQkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IDIwMjMgU0FQIFNwYXJ0YWN1cyB0ZWFtIDxzcGFydGFjdXMtdGVhbUBzYXAuY29tPlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWN0aW9ucywgY3JlYXRlRWZmZWN0LCBvZlR5cGUgfSBmcm9tICdAbmdyeC9lZmZlY3RzJztcbmltcG9ydCB7IFN0b3JlLCBzZWxlY3QgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyBFTVBUWSwgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNvbmNhdE1hcCxcbiAgZGVsYXksXG4gIGZpbHRlcixcbiAgbWFwLFxuICBzd2l0Y2hNYXAsXG4gIHRha2UsXG4gIHdpdGhMYXRlc3RGcm9tLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUcmFuc2xhdGFibGUgfSBmcm9tICcuLi8uLi8uLi9pMThuL3RyYW5zbGF0YWJsZSc7XG5pbXBvcnQgeyBPYmplY3RDb21wYXJpc29uVXRpbHMgfSBmcm9tICcuLi8uLi8uLi91dGlsL29iamVjdC1jb21wYXJpc29uLXV0aWxzJztcbmltcG9ydCB7IGlzTm90VW5kZWZpbmVkIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC90eXBlLWd1YXJkcyc7XG5pbXBvcnQgeyBHbG9iYWxNZXNzYWdlQ29uZmlnIH0gZnJvbSAnLi4vLi4vY29uZmlnL2dsb2JhbC1tZXNzYWdlLWNvbmZpZyc7XG5pbXBvcnQgeyBHbG9iYWxNZXNzYWdlQWN0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvaW5kZXgnO1xuaW1wb3J0IHsgU3RhdGVXaXRoR2xvYmFsTWVzc2FnZSB9IGZyb20gJy4uL2dsb2JhbC1tZXNzYWdlLXN0YXRlJztcbmltcG9ydCB7IEdsb2JhbE1lc3NhZ2VTZWxlY3RvcnMgfSBmcm9tICcuLi9zZWxlY3RvcnMvaW5kZXgnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgR2xvYmFsTWVzc2FnZUVmZmVjdCB7XG4gIHJlbW92ZUR1cGxpY2F0ZWQkOiBPYnNlcnZhYmxlPEdsb2JhbE1lc3NhZ2VBY3Rpb25zLlJlbW92ZU1lc3NhZ2U+ID1cbiAgICBjcmVhdGVFZmZlY3QoKCkgPT5cbiAgICAgIHRoaXMuYWN0aW9ucyQucGlwZShcbiAgICAgICAgb2ZUeXBlKEdsb2JhbE1lc3NhZ2VBY3Rpb25zLkFERF9NRVNTQUdFKSxcbiAgICAgICAgbWFwKChhY3Rpb24pID0+IChhY3Rpb24gYXMgR2xvYmFsTWVzc2FnZUFjdGlvbnMuQWRkTWVzc2FnZSkucGF5bG9hZCksXG4gICAgICAgIHN3aXRjaE1hcCgobWVzc2FnZSkgPT5cbiAgICAgICAgICBvZihtZXNzYWdlLnRleHQpLnBpcGUoXG4gICAgICAgICAgICB3aXRoTGF0ZXN0RnJvbShcbiAgICAgICAgICAgICAgdGhpcy5zdG9yZS5waXBlKFxuICAgICAgICAgICAgICAgIHNlbGVjdChcbiAgICAgICAgICAgICAgICAgIEdsb2JhbE1lc3NhZ2VTZWxlY3RvcnMuZ2V0R2xvYmFsTWVzc2FnZUVudGl0aWVzQnlUeXBlKFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGVcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBmaWx0ZXIoXG4gICAgICAgICAgICAgIChbdGV4dCwgbWVzc2FnZXNdOiBbVHJhbnNsYXRhYmxlLCBUcmFuc2xhdGFibGVbXV0pID0+XG4gICAgICAgICAgICAgICAgT2JqZWN0Q29tcGFyaXNvblV0aWxzLmNvdW50T2ZEZWVwRXF1YWxPYmplY3RzKHRleHQsIG1lc3NhZ2VzKSA+XG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1hcCgoW3RleHQsIG1lc3NhZ2VzXTogW1RyYW5zbGF0YWJsZSwgVHJhbnNsYXRhYmxlW11dKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gT2JqZWN0Q29tcGFyaXNvblV0aWxzLmluZGV4T2ZGaXJzdE9jY3VycmVuY2UoXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsTWVzc2FnZUFjdGlvbnMuUmVtb3ZlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBtZXNzYWdlLnR5cGUsXG4gICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmaWx0ZXIoaXNOb3RVbmRlZmluZWQpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcblxuICBoaWRlQWZ0ZXJEZWxheSQ6XG4gICAgfCBPYnNlcnZhYmxlPEdsb2JhbE1lc3NhZ2VBY3Rpb25zLlJlbW92ZU1lc3NhZ2U+XG4gICAgfCAoKCkgPT4gT2JzZXJ2YWJsZTxuZXZlcj4pID0gY3JlYXRlRWZmZWN0KCgpID0+XG4gICAgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAvLyB3ZSBkb24ndCB3YW50IHRvIHJ1biB0aGlzIGxvZ2ljIHdoZW4gZG9pbmcgU1NSXG4gICAgICA/IHRoaXMuYWN0aW9ucyQucGlwZShcbiAgICAgICAgICBvZlR5cGUoR2xvYmFsTWVzc2FnZUFjdGlvbnMuQUREX01FU1NBR0UpLFxuICAgICAgICAgIG1hcCgoYWN0aW9uKSA9PiAoYWN0aW9uIGFzIEdsb2JhbE1lc3NhZ2VBY3Rpb25zLkFkZE1lc3NhZ2UpLnBheWxvYWQpLFxuICAgICAgICAgIGNvbmNhdE1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcuZ2xvYmFsTWVzc2FnZXM/LlttZXNzYWdlLnR5cGVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUucGlwZShcbiAgICAgICAgICAgICAgc2VsZWN0KFxuICAgICAgICAgICAgICAgIEdsb2JhbE1lc3NhZ2VTZWxlY3RvcnMuZ2V0R2xvYmFsTWVzc2FnZUNvdW50QnlUeXBlKG1lc3NhZ2UudHlwZSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgICAgICAgZmlsdGVyKFxuICAgICAgICAgICAgICAgIChjb3VudDogbnVtYmVyKSA9PlxuICAgICAgICAgICAgICAgICAgKChjb25maWcgJiYgY29uZmlnLnRpbWVvdXQgIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lb3V0ICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgICBjb3VudCA+IDBcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgZGVsYXkoKG1lc3NhZ2UudGltZW91dCBhcyBudW1iZXIpIHx8IChjb25maWc/LnRpbWVvdXQgYXMgbnVtYmVyKSksXG4gICAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PlxuICAgICAgICAgICAgICAgIG9mKFxuICAgICAgICAgICAgICAgICAgbmV3IEdsb2JhbE1lc3NhZ2VBY3Rpb25zLlJlbW92ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBtZXNzYWdlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgOiAvLyB3b3JrYXJvdW5kIGlzIHJlcXVpcmVkIGR1ZSB0byBOR1JYIG11dGF0aW5nIGEgZ2xvYmFsIHN0YXRpY1xuICAgICAgICAvLyBvYnNlcnZhYmxlIEVNUFRZLCBjYXVzaW5nIHRvIHRocm93IGFuIGVycm9yIGlmIHdlIGhhdmVcbiAgICAgICAgLy8gZWZmZWN0IHJlZ2lzdGVyZWQgb24gdGhlIHNhbWUgb2JzZXJ2YWJsZSB0d2ljZVxuICAgICAgICAoKSA9PiBFTVBUWVxuICApO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgYWN0aW9ucyQ6IEFjdGlvbnMsXG4gICAgcHJpdmF0ZSBzdG9yZTogU3RvcmU8U3RhdGVXaXRoR2xvYmFsTWVzc2FnZT4sXG4gICAgcHJpdmF0ZSBjb25maWc6IEdsb2JhbE1lc3NhZ2VDb25maWcsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBhbnlcbiAgKSB7fVxufVxuIl19